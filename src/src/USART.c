/***********************************
*串口相关操作
***********************************/
#include "USART.h"
/*------------------------------ 变量定义区 ----------------------------------*/
uchar USART0_Rev;    //串口0接收值 
uchar USART1_Rev;    //串口1接收值
/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
函数功能：串口0初始化
入口参数：无
返回值：无
------------------------------------------------------------------------------*/
void Init_USART0(void)
  {
//====================串口工作模式设置========================================
    U0CTL = 0x00;      // U0CTL包含串口0通信协议、通信模式、校验位等设置，允许UART0
    U0CTL |= CHAR;    //(CHAR=0x10)当CHAR=0时位7位数据，当 CHAR=1时为8位数据 
                     //不需要校验，数据位为8位，无反馈，异步UART通信，UART被允许
//====================串口发送操作设置========================================
    U0TCTL = 0x00;     //U0TCTL包含串口0发送功能操作
    U0TCTL |= SSEL0;  //波特率发生器选择ACLK 
                     //#define SSEL1  (0x20)       #define SSEL0  (0x10)
//====================串口拨特率设置9600====================================
//===================拨特率计算公式：拨特率=BRCLK/（UBR+（M7+M6+。。。。+M0）/8）
    UBR0_0 = 0x03;     //UBR0_0为串口0波特率整数部分低地址 
    UBR1_0 = 0x00;     //UBR1_0为串口0波特率整数部分高地址 
    UMCTL_0 = 0x4A;    //UBR1_0为串口0波特率小数部分高地址 
//===================串口收发使能控制=========================================
    ME1 |= UTXE0;    //串口0发送功能使能
    ME1 |= URXE0;    //串口0接收功能使能    
//===================串口中断使能控制=========================================
    IE1 |= URXIE0;   //串口0接收中断使能
//  IE1 |= UTXIE0;   //串口0发送中断使能
//===================端口第二功能使能=========================================
    P3SEL |=BIT4;    //设置P3.4为UART0 的TXD
    P3SEL |=BIT5;    //设置P3.5为UART0 的RXD
    P3DIR |=BIT4;    //设置P3.4为输出
}
/*------------------------------------------------------------------------------
函数功能：串口1初始化
入口参数：无
返回值：无
------------------------------------------------------------------------------*/
void Init_USART1(void)
  {
//====================串口工作模式设置========================================
    U1CTL = 0x00;      // U0CTL包含串口0通信协议、通信模式、校验位等设置，允许UART0
    U1CTL |=CHAR;    //(CHAR=0x10)当CHAR=0时位7位数据，当 CHAR=1时为8位数据 
                     //不需要校验，数据位为8位，无反馈，异步UART通信，UART被允许
//====================串口发送操作设置========================================
    U1TCTL = 0x00;     //U0TCTL包含串口0发送功能操作
    U1TCTL |= SSEL0;  //波特率发生器选择ACLK 
                     //#define SSEL1  (0x20)       #define SSEL0  (0x10)
//====================串口拨特率设置9600====================================
//===================拨特率计算公式：拨特率=BRCLK/（UBR+（M7+M6+。。。。+M0）/8）
    UBR0_1=0x03;     //UBR0_0为串口0波特率整数部分低地址 
    UBR1_1=0x00;     //UBR1_0为串口0波特率整数部分高地址 
    UMCTL_1=0x4A;    //UBR1_0为串口0波特率小数部分高地址 
//===================串口收发使能控制=========================================
    ME2 |= UTXE1;    //串口0发送功能使能
    ME2 |= URXE1;    //串口0接收功能使能    
//===================串口中断使能控制=========================================
//  IE2 |= URXIE1;   //串口0接收中断使能
//   IE2 |= UTXIE1;   //串口0发送中断使能
//===================端口第二功能使能=========================================
    P3SEL |=BIT6;    //设置P3.6为UART0 的TXD
    P3SEL |=BIT7;    //设置P3.7为UART0 的RXD
    P3DIR |=BIT6;    //设置P3.6为输出
}
/*------------------------------------------------------------------------------
函数功能：串口0发送一字节数据
入口参数：待发送数据
返回值：无
------------------------------------------------------------------------------*/
void USART0_Send_Byte(uchar Byte)
{
    while(!(IFG1 & UTXIFG0));
    TXBUF0 = Byte;
}
/*------------------------------------------------------------------------------
函数功能：串口1送一字节数据
入口参数：待发送数据
返回值：无
------------------------------------------------------------------------------*/
void USART1_Send_Byte(uchar Byte)
{
    while(!(IFG2 & UTXIFG1));	//
    TXBUF1=Byte;
}
/*------------------------------------------------------------------------------
函数功能：串口0发送字符串
入口参数：待发送字符串
返回值：无
------------------------------------------------------------------------------*/
void USART0_Send_String(uchar *ptr)
{
      while(*ptr != '\0')
      {
       while (!(IFG1 & UTXIFG0));                // TX缓存空闲？the IFG1 set when U0TXBUF is empty
       TXBUF0 = *ptr++;                       // 发送数据
      }
      while (!(IFG1 & UTXIFG0));
      TXBUF0 = '\n';
}
/*------------------------------------------------------------------------------
函数功能：串口0发送字符串
入口参数：待发送字符串
返回值：无
------------------------------------------------------------------------------*/
void USART1_Send_String(uchar *ptr)
{
      while(*ptr != '\0')
      {
       while (!(IFG2 & UTXIFG1));                // TX缓存空闲？the IFG1 set when U0TXBUF is empty
       TXBUF1 = *ptr++;                       // 发送数据
      }
      while (!(IFG2 & UTXIFG1));
      TXBUF1 = '\n';
}
/*------------------------------------------------------------------------------
函数功能：串口0接收一字节数据
入口参数：无
返回值：接收数据
------------------------------------------------------------------------------*/
uchar USART0_Rev_Byte(void)
{
 uchar Byte_tmp;
 while(!(IFG1 & URXIFG0));  //防止一直没有数据进入死循环
 Byte_tmp = RXBUF0;
 return Byte_tmp;
}
/*------------------------------------------------------------------------------
函数功能：串口1接收一字节数据
入口参数：无
返回值：接收数据
------------------------------------------------------------------------------*/
uchar USART1_Rev_Byte(void)
{
 uchar Byte_tmp;
 while(!(IFG2 & URXIFG1)); 
 Byte_tmp = RXBUF1;
 return Byte_tmp;
}
/*------------------------------------------------------------------------------
函数功能：串口0接收字符串
入口参数：无
返回值：接收字符串
------------------------------------------------------------------------------
uchar USART0_Rev_String(void)
{
;
}*/
/*------------------------------------------------------------------------------
函数功能：串口1接收字符串
入口参数：无
返回值：接收字符串
------------------------------------------------------------------------------
uchar USART1_Rev_String(void)
{
;
}*/
/*******************************************
函数名称：UART0_RXISR
功    能：UART0的接收中断服务函数，在这里唤醒
          CPU，使它退出低功耗模式
参    数：无
返回值  ：无
********************************************/
#pragma vector = UART0RX_VECTOR
__interrupt void UART0_RXISR(void)
{
  USART0_Rev = RXBUF0;
  USART0_Send_Byte(USART0_Rev);
}
/*******************************************
函数名称：UART0_RXISR
功    能：UART0的接收中断服务函数，在这里唤醒
          CPU，使它退出低功耗模式
参    数：无
返回值  ：无
********************************************/
#pragma vector = UART1RX_VECTOR
__interrupt void UART1_RXISR(void)
{
  USART1_Rev = RXBUF1;
  USART1_Send_Byte(USART1_Rev);
}
